# 反射

## class

java中除了基本类型外,都是class,interface也算入class中

class(包括interface)的本质是数据类型(Type)

无继承关系的数据类型无法赋值

## Class

class/interface的数据类型是Class

JVM每加载一个class, JVM就为其创建一个Class类型的实例,并关联起来.

例如: 

1.加载String类:读取String.class文件 

2.为String类创建一个Class实例:
```
Class cls = new Class(String);
```

一个Class实例包含了该class的完整信息

```
//Class实例(String)
name:"java.lang.String"
package:"java.lange"
supre:java.lang.Object
interface:CharSequence,
field:value[],hash
methode:indexOf,valueOf
```

### 作用

* JVM为每个加载的`class`创建对应的`Class`实例,并在实例中保存该`class`的所有信息
* 如果获取了某个`Class`实例,则可以获取到该实例对应的`class`的所有信息
* 通过`Class`实例获取`class`信息的方法称为反射( Reflection )

## 获取class的Class实例

* Type.class
```
Class c = String.class;
```

* getClass()
```
String s = "";
Class cls = s.getClass();
```

* Class.forName()
```
Class cls = Class.forName("java.lang.String");
```

## Class在JVM中唯一

Class在JVM中唯一, 所以可以用==比较两个Class实例

## Class实例比较与instanceof的差别

```
Integer n = new Integer(123);

n instanceof Integer; //true
n instanceof Number; //true

n.getClass() == Integer.class; //true
n.getClass() == Number.class; //false
```

## Class方法

获取信息

* getName() 
```
String.class.getName() //java.lang.String
```

* getSimpleName()
```
String.class.getSimpleName() //String
```

* getPackage()
```
String.class.getPackage().getName() //java.lang
```

判断是否为某种类型

* isInterface()
* isEnum()
* isArray()
* isPrimitive() //判断是否为基本类型

创建class实例

* newInstance() //只能调用 无参数 构造方法

## 动态加载

利用JVM动态加载class的特效, 可以在运行期更具条件加载不同的实现类

```
public class Main {
    public static void main(String[] args) {
        if (isClassPresent("Test")) {
            new Test();
        } else {
            System.out.println("没有测试类");
        }
    }
    
    static boolean isClassPresent(String name) {
        try {
            Class.forName(name);
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        }
    }
}

class Test {

}
```

# 总结

* JVM为每个加载的`class`创建对应的`Class`实例,并在实例中保存该`class`的所有信息

* 如果获取了某个`Class`实例,则可以获取到该实例对应的`class`的所有信息

* 通过`Class`实例获取`class`信息的方法称为反射( Reflection )

* JVM总是动态加载class, 可以在运行期更具条件加载不同的实现类








